using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System;

using UnityEngine.Networking;

using SoftRare.Serialization;


namespace SoftRare.Net {
    [RequireComponent(typeof(NetworkIdentity))]
    public
#if IS_UNLICENSED
        sealed
#endif 
        class NetObject : NetworkBehaviour {

        #region member vars
        [Tooltip("Decide here whether you want this NetObject to represent a networked player so e.g. a character which can be controlled by a real player as a client, or whether you want it to represent a non-player object (NPO). This can be e.g. an NPC or another object of which data will be synchronized across the network. Keep in mind that if you choose this to be a player, the setting 'Local Player Authority' on the 'NetworkIdentity' component on this NetObject is quite important, as uMMO will handle it accordingly. If you activate 'Local Player Authority' this NetObject will be completely controlled by the client for whom it was spawned. That means it is in charge of setting all kinds of values, like current position, rotation, ect. To have 'Local Player Authority' activated is less safe than if you leave it deactivated. If you don't activate (that checkbox on the NetworkIdentity component) the server has authority over the values. That means that e.g. to control the character's movement, you need to send the input you would normally read locally to the server so that it is read and executed there and you get the result of that input synchronized back to you. That sounds complicated but luckily uMMO does that all for you (for further information read on the 'InputCollectionMethod' property). Server authority is more safe. E.g. a player can than not simply tell the server a position in world space where he wants to be, to be teleported there instantly, possibly without this feature even being available legally. With every networked software always remember this important saying: 'Never trust the client!'")]
        public ObjectType objectType;

        // #<-- possibly only for testing:
        [Tooltip("For setups where the server has authority over the player object (you can switch this setting on the NetworkIdentity component on this NetObject) you define whether you want to collect certain input axes/keys/mouse buttons every frame (CollectEveryFrame) or whether you want to have the input values collected automatically on demand (CollectOnDemand). For the latter make sure your player controller scripts inherit from SoftRare.Net.PlayerAction so that you can substitute in a particular script e.g. Input.GetAxis(\"Horizontal\") with uMMO_Input.GetAxis(\"Horizontal\"). In that case you don't need to do anything else anymore. Your input will be automatically sent to the server.")]
        public InputCollectionMethod inputCollectionMethod = InputCollectionMethod.CollectEveryFrame;
        [Tooltip("For setups where the server has authority over the player object (you can switch this setting on the NetworkIdentity component on this NetObject) you can decide here whether input values should be sent in the Update() function or in LateUpdate(). Both are executed every frame, whereas LateUpdate() is being executed directly after Update().")]
        public InputSendingMethod inputSendingMethod = InputSendingMethod.SendIn_Update;
        [Tooltip("Decide here whether you want to allow an input value which was either generated by input from the local player or received via the network to be read multiple times or just once. At the moment this feature is being tested and it is unclear whether it will be kept as an option.")]
        public InputReadingMethod inputReadingMethod = InputReadingMethod.CanReadSameValueMultipleTimes;
        [Tooltip("Decide here whether you want to store or clear received input states. These are at the moment not used, so usually you will want to have them cleared so that they don't take up memory unnecessarily. At the moment this feature is being tested and it is unclear whether it will be kept as an option.")]
        public bool clearInputStates = true;
        // -->#

        [Tooltip("For setups where the server has authority over the player object (you can switch this setting on the NetworkIdentity component on this NetObject) you can define the input axes here of which the values should transfered from client to server so that the movement itsself can be executed on the server.\n\nATTENTION: If this list contains EMPTY values don't worry, they are not list. Simply restart Unity to have them reappear. This is a bug which needs to addressed. As far as we can tell it occurs e.g. when you Update to a new Unity version, as a certain callback is then not executed for some unexplicable reason.")]
        public List<int> inputFromAxesToSendToServer = new List<int>();
        [Tooltip("For setups where the server has authority over the player object (you can switch this setting on the NetworkIdentity component on this NetObject) you can define the keys here of which the input values should transfered from client to server so that the movement itsself can be executed on the server.\n\nATTENTION: If this list contains EMPTY values don't worry, they are not list. Simply restart Unity to have them reappear. This is a bug which needs to addressed. As far as we can tell it occurs e.g. when you Update to a new Unity version, as a certain callback is then not executed for some unexplicable reason.")]
        public List<KeyCode> inputFromKeysToSendToServer = new List<KeyCode>();
        [Tooltip("For setups where the server has authority over the player object (you can switch this setting on the NetworkIdentity component on this NetObject) you can define the mouse buttons here of which the input values should transfered from client to server so that the movement itsself can be executed on the server.\n\nATTENTION: If this list contains EMPTY values don't worry, they are not list. Simply restart Unity to have them reappear. This is a bug which needs to addressed. As far as we can tell it occurs e.g. when you Update to a new Unity version, as a certain callback is then not executed for some unexplicable reason.")]
        public List<MouseButton> inputFromMouseButtonsToSendToServer = new List<MouseButton>();
        //public List<MouseButton> otherInputToSendToServer = new List<MouseButton>();
        
        public List<bool> activeCallbacks = new List<bool>();

        [Tooltip("Configure here in what way you would like the position and rotation of this NetObject to be synchronized:\n\nSyncUsing_DEFAULT_NATIVE_COMPONENT: This setting causes a 'NetworkTransform' component to be added to this NetObject. It is a native UNET component.\n\nSyncUsing_DEFAULT_uMMO_PLUGIN: This setting causes a default uMMO plugin to be added automatically to this NetObject once it is instantiated in-game. It is a plugin with the purpose of synchronizing position and rotation.\n\nDeveloperResponsibility_NO_AUTOMATIC_ACTION: Use this setting if you want to add a method of synchronizing position and rotation yourself, without any automatic action. Choose this if you know what you are doing.")]
        public SyncingMethod transformSyncingMethod = SyncingMethod.SyncUsing_DEFAULT_NATIVE_COMPONENT;
        [Tooltip("Configure here in what way you would like the animations of this NetObject to be synchronized:\n\nSyncUsing_DEFAULT_NATIVE_COMPONENT: This setting causes a 'NetworkAnimator' component to be added to this NetObject. It is a native UNET component.\n\nSyncUsing_DEFAULT_uMMO_PLUGIN: This setting causes a default uMMO plugin to be added automatically to this NetObject once it is instantiated in-game. It is a plugin with the purpose of synchronizing animations, either for Unity's legacy animation system or Mecanim.\n\nDeveloperResponsibility_NO_AUTOMATIC_ACTION: Use this setting if you want to add a method of synchronizing animations yourself, without any automatic action. Choose this if you know what you are doing.")]
        public SyncingMethod animationSyncingMethod = SyncingMethod.SyncUsing_DEFAULT_NATIVE_COMPONENT;

        [Tooltip("This 'commands' plugins activated on this NetObject to syncronize the position in 2d/3d space. Whether this is then really done depends on the plugin(s) which are actually activated on this NetObject at runtime. For more information read on 'Authority Serializer Plugins'.")]
        public bool pluginShouldSyncPosition = true;
        [Tooltip("This 'commands' plugins activated on this NetObject to syncronize the rotation in 2d/3d space. Whether this is then really done depends on the plugin(s) which are actually activated on this NetObject at runtime. For more information read on 'Authority Serializer Plugins'.")]
        public bool pluginShouldSyncRotation = true;
        [Tooltip("This 'commands' plugins activated on this NetObject to syncronize the animations of the character behind this NetObject in real time. Whether this is then really done depends on the plugin(s) which are actually activated on this NetObject at runtime. For more information read on 'Authority Serializer Plugins'.")]
        public bool pluginShouldSyncAnimations = true;

        public bool usesMecanim = false;
        public bool usesLegacyAnims = false;
        public Animation animationComp = null;
        public Animator animatorComp = null;

        protected List<List<Component>> scriptLists = new List<List<Component>>();
        protected List<List<string>> runtimeScriptLists = new List<List<string>>();

        [Tooltip("Activate this to be presented with several 'lists' of possible spawn cases. A spawn case is e.g. that this NetObject is being spawned on a client which is the client who is actually in control of this NetObject (meaning he can e.g. move the character). In that case all scripts and components (such as child transforms of this NetObject) that you drag-and-dropped to the list 'clientLocalPlayerScripts' are being activated once the NetObject is being instantiated. All scripts which are in EITHER of the other spawn case lists and NOT simultaneously in this one, are being REMOVED once this NetObject is being instantiated in-game (your actual prefab is not touched though). This makes uMMO very flexible in the sense that script separation is encouraged and that you can specify exactly how this NetObject should behave on what machine. Read on the appropriate list about specific spawn cases.")]
        public bool handelScriptsBasedOnSpawnCase;
        [Tooltip("This list handles the case that this NetObject is being spawned on a client which is the client who is actually in control of this NetObject (meaning he can e.g. move the character).")]
        public List<Component> clientLocalPlayerScripts; //movement/behaviour scripts for local players ( executed on client side )
        [Tooltip("This list handles the case that this NetObject is being spawned on a client which is NOT the client who is actually in control of this NetObject. So this is for all scripts who should be activated on 'fellow players' so to speak, remote players.")]
        public List<Component> clientRemotePlayerScripts; //aim on/click on/mark scripts for remote players ( executed on client side )
        [Tooltip("This list handles the case that this NetObject is being spawned on the server for a NetObject which represents a player.")]
        public List<Component> serverPlayerScripts; //collision scripts for players ( executed on server side )
        [Tooltip("This list handles the case that this NetObject is being spawned on the server for a NetObject which represents an object which is NOT a player, but e.g. an NPC.")]
        public List<Component> serverNPOScripts; //movement/behaviour scripts for Non-Player-Objects ( executed on server side )
        [Tooltip("This list handles the case that this NetObject is being spawned on the client for a NetObject which represents an object which is NOT a player, but e.g. an NPC.")]
        public List<Component> clientNPOScripts; //aim on/click on/mark scripts for Non-Player-Objects ( executed on client side )

        //equivalent of lists above, only scripts are detected at runtime
        [Tooltip("This has the same functionality as 'handelScriptsBasedOnSpawnCase' except for the fact that instead of dragging-and-dropping scripts/components to the lists you write their names (as strings) in the fields of these lists. This way their spawn case is being handled once the NetObject is being instantiated. This has the effect that you can even handle spawn cases of scripts/components which are only being created at runtime. Read up on the appropriate spawn case lists above in the 'NON-Runtime spawn list documentation'.")]
        public bool handelScriptsBasedOnSpawnCaseAtRuntime;
        public List<string> clientLocalPlayerRuntimeScripts;
        public List<string> clientRemotePlayerRuntimeScripts;
        public List<string> serverPlayerRuntimeScripts;
        public List<string> serverNPORuntimeScripts;
        public List<string> clientNPORuntimeScripts;

        // a static variable which returns the uMMO_NetObject of the GameObject which is under control by the current network player
        public static NetObject LOCAL_PLAYER_OBJECT = null;

        [Tooltip("Messenger Plugins are plugins you can use to send data. Authority Serializer Plugins in example are 'children' of Messenger Plugins. They use the functionality of Messenger Plugins and 'extend' those with their own functionality. Authority Serializer Plugins have only one aim: serialize the values on the machine that actually has authority to the ones that don't. So if your local client has authority for its player character it will serialize its values (which ones is depending on the plugin itsself. You, the developer can write your own plugins by inheriting from the class PL_AuthoritySerializer) and send them to the same NetObject on the server. The server will relay that information to the other clients.\n\nThere are 3 ways to add a plugin to a NetObject:\n\n1. You can just drag and drop a plugin here from 'Assets/uMMO/prefab/plugins'. You can do that while this NetObject is just a prefab in project view or - in case of a non-player object (NPO) - while it is located in the scene. Just drop them on this list and they will be activated when the NetObject is in-game.\n2. You can also add the plugins from 'Assets/uMMO/prefab/plugins' directly as child of a NetObject prefab or ingame-NPO.\n 3. You can also choose not do anything and let uMMO use a default plugin. This is done by selecting SyncUsing_DEFAULT_uMMO_PLUGIN further above as syncing method.")]
        public List<Plugin.PL_Messenger> messengerPlugins = new List<Plugin.PL_Messenger>();

        public NetState pluginValueSyncer;

        public List<int> mecanimVarsToSync = new List<int>();

        public List<NetState> inputStates = new List<NetState>();

        const bool PRINT_INPUTPROCESSING_DEBUG = false;

        const bool PRINT_PLUGIN_DEBUG = false;

        //public bool localPlayerGeneratingInput = false;
        protected NetState mostRecentInputState;
        #endregion


        #region callbacks
        public static string[] callbackValues() {
            return new string[] { "__uMMO_localPlayer_init", "__uMMO_remotePlayer_init", "__uMMO_serverPlayer_init", "__uMMO_clientNPO_init", "__uMMO_serverNPO_init" };
        }

        protected bool IsCallbackActivated(string functionName) {
            bool ret = false;
            if (activeCallbacks.Count > 0) {
                string[] callbacksAr = callbackValues();
                List<string> callbacksList = new List<string>();
                foreach (string cb in callbacksAr) {
                    callbacksList.Add(cb);
                }
                int callbackIndex = callbacksList.IndexOf(functionName);
                ret = activeCallbacks[callbackIndex];
            }
            return ret;
        }

        // decides whether custom callback/event function call should be executed. Switch this on in the Editor
        protected void sendCallbackToGO(string functionName, object parameter) {

            if (IsCallbackActivated(functionName)) {
                gameObject.SendMessage(functionName, parameter, SendMessageOptions.RequireReceiver);

                /*foreach (uMMO_NetObject_Module mod in allModules) {
                    mod.gameObject.SendMessage(functionName, parameter, SendMessageOptions.DontRequireReceiver);
                }*/
            }
        }
        #endregion

        // a static variable which returns the NetObject of the GameObject which is under control by the current network player.
        //  Use this to access input values. To read up on how to use this, please refer to the in-Editor documentation on the attribute "input2Check" of this component. */
        public static NetObject REF(Component c) {
            return c.GetComponent<NetObject>();
        }

        #region spawn case processing
        // main uMMO feature, read up on it in in-Editor documentation
        protected void handleListAndRemoveUnneccessary(List<Component> list2process) {

            List<Component> componentsToKill = new List<Component>();
            foreach (List<Component> currList in scriptLists) {
                if (currList != list2process) {

                    foreach (Component otherScript in currList) {
                        if (otherScript != null) {
                            //string scriptName = Utils.Library.ObjectDebugName2ScriptName(otherScript + "");

                            if (list2process.IndexOf(otherScript) == -1) {

                                if (otherScript.GetType() != typeof(Transform))
                                    componentsToKill.Add(otherScript);
                                else
                                    Destroy(otherScript.gameObject);

                            }
                        }
                    }
                }
            }

            Utils.Library.killScriptsRequiredInclusive(componentsToKill);

        }

        protected void handleListAndRemoveUnneccessary(List<string> list2process) {

            List<Component> componentsToKill = new List<Component>();
            foreach (List<string> currList in runtimeScriptLists) {
                if (currList != list2process) {

                    foreach (string otherScriptName in currList) {

                        Component otherScript = Utils.Library.findComponentInChildren(otherScriptName, this.gameObject);

                        if (otherScript != null && list2process.IndexOf(otherScript.GetType().ToString()) == -1) {

                            if (otherScript.GetType() != typeof(Transform))
                                componentsToKill.Add(otherScript);
                            else
                                Destroy(otherScript.gameObject);
                        }
                    }
                }
            }

            Utils.Library.killScriptsRequiredInclusive(componentsToKill);

        }
        #endregion

        #region input processing

        protected string inputNameOfIndex(int index) {
            string ret = null;
            if (inputFromAxesToSendToServer.Count > 0) {
                string[] inputsAr = InputAxes.mergedValues();
                ret = inputsAr[index];
            }
            return ret;
        }

        [Client]
        protected void collectInputEveryFrame() {
            if (isLocalPlayer && !localPlayerAuthority) {
                NetState newInputState = new NetState(Utils.Library.NetworkTime);

                foreach (int inputIndex in inputFromAxesToSendToServer) {
                    string inputName = inputNameOfIndex(inputIndex);
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.Axis, inputName);
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.AxisRaw, inputName);
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.Button, inputName);
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.ButtonUp, inputName);
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.ButtonDown, inputName);
                }

                foreach (int mb in inputFromMouseButtonsToSendToServer) {
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.MouseButton, mb + "");
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.MouseButtonUp, mb + "");
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.MouseButtonDown, mb + "");
                }

                foreach (KeyCode key in inputFromKeysToSendToServer) {
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.Key_CODE, ((int)key).ToString());
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.KeyUp_CODE, ((int)key).ToString());
                    newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(InputType.KeyDown_CODE, ((int)key).ToString());
                }

                if (newInputState.containsInput) {
                    var serializedInputState = newInputState.serialize();
                    CmdReceiveInputFromClient(serializedInputState);
                    clientSendsInputAdditinalFuncs(serializedInputState);
                    registerNewInputState(newInputState);
                }
            }
        }

        [Client]
        protected void collectInputOnDemand() {
            if (isLocalPlayer && !localPlayerAuthority) {
                if (mostRecentInputState != null) {
                    if (mostRecentInputState.containsInput) {
                        var serializedInputState = mostRecentInputState.serialize();
                        CmdReceiveInputFromClient(serializedInputState);
                        clientSendsInputAdditinalFuncs(serializedInputState);
                        registerNewInputState(mostRecentInputState);
                        mostRecentInputState = new NetState(Utils.Library.NetworkTime);
                    }
                }
            }
        }

        protected void clientSendsInputAdditinalFuncs(string serializedInputState) {
            if (PRINT_INPUTPROCESSING_DEBUG)
                print("CLIENT sends: " + serializedInputState);
        }

        protected void serverRecvsInputAdditinalFuncs(string serializedInputState) {
            if (PRINT_INPUTPROCESSING_DEBUG)
                print("SERVER recvs: " + serializedInputState);
        }

        [Client]
        protected void collectInputAndSend() {
            if (inputCollectionMethod == InputCollectionMethod.CollectEveryFrame) {
                collectInputEveryFrame();
            } else if (inputCollectionMethod == InputCollectionMethod.CollectOnDemand) {
                collectInputOnDemand();
            }
        }

        // Update() is called once per frame
        //[ClientCallback]
        void Update() {

            if (isClient && inputSendingMethod == InputSendingMethod.SendIn_Update) {
                collectInputAndSend();
            }

            /*// AuthoritySerializer plugin execution: (moved to PL_AuthoritySerializer)
            foreach (Plugin.PL_AuthoritySerializer pl_as in authoritySerializerPlugins) {
                if (pl_as.initialized) {
                    if (hasAuthority) {
                        pl_as.OnAuthoritySerialize();
                    } else {
                        pl_as.OnNonAuthorityDeserialize();
                    }
                }
            }*/
        }

        // LateUpdate() is called once per frame after Update()
        [ClientCallback]
        void LateUpdate() {
            if (inputSendingMethod == InputSendingMethod.SendIn_LateUpdate) {
                collectInputAndSend();
            }
        }

        public void registerNewInputState(NetState inputState) {
            if (clearInputStates) {
                if (inputStates.Count < 1) {
                    inputStates.Add(inputState);
                } else {
                    inputStates[0] = inputState;
                }
            } else {
                inputStates.Add(inputState);
            }
        }

        [Command]
        public void CmdReceiveInputFromClient(string serializedInputState) {
            serverRecvsInputAdditinalFuncs(serializedInputState);
            registerNewInputState(NetState.deserialize(serializedInputState));

        }

        [ClientRpc]
        protected void RpcRemoteClientRecvValue(string inputType, string inputAxis, string serializedValue) {
            if (!isLocalPlayer) {
                AValue value = AValue.deserialize(serializedValue);
                NetState newInputState = new NetState(Utils.Library.NetworkTime);
                newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(inputType, inputAxis, value);
                registerNewInputState(newInputState);
            }
        }

        protected AValue getValueOfLatest(InputType inputType, string inputAxis) {
            AValue ret = null;
            if (inputStates.Count > 0) {
                NetState mostRecent = inputStates[inputStates.Count - 1];
                ret = mostRecent.getAxisValueOfInputType(((int)inputType).ToString(), inputAxis, inputReadingMethod);
            }
            return ret;
        }

        protected AValue GetInput(InputType inputType, string inputAxis) {
            AValue ret = null;
            if (uMMO.get.isClient && isLocalPlayer) {
                ret = AValue.GetLocalInputByNativeAPI(inputType, inputAxis);

                if (!localPlayerAuthority && inputCollectionMethod == InputCollectionMethod.CollectOnDemand) {        //if authoritative server && not sending input automatically:

                    if (mostRecentInputState != null) {
                        mostRecentInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(inputType, inputAxis, ret);
                    }
                }
            } else if (uMMO.get.isServer) {
                ret = getValueOfLatest(inputType, inputAxis);
            }
            return ret;
        }
        protected AValue GetInputSENDTOALL(InputType inputType, string inputAxis) {
            AValue ret = GetInput(inputType, inputAxis);

            if (uMMO.get.isServer) {
                if (ret != null)
                    RpcRemoteClientRecvValue(((int)inputType).ToString(), inputAxis, ret.serialize()); //TODO fix to NOT always send to everyone (no need to send back to the local client)
                                                                                                       //answers.unity3d.com/questions/984750/unitynetworking-unet-rpc-to-specific-player-master.html
            } else if (uMMO.get.isClient && !isLocalPlayer) {
                ret = getValueOfLatest(inputType, inputAxis);
            } else if (uMMO.get.isClient && localPlayerAuthority && isLocalPlayer) {

                NetState newInputState = new NetState(Utils.Library.NetworkTime);
                newInputState.addNewAxisValueToInputTypeBasedOnCurrentInput(inputType, inputAxis, ret);
                AValue mostRecentVal = null;
                mostRecentVal = getValueOfLatest(inputType, inputAxis);
                if (mostRecentVal == null || ret != mostRecentVal) {
                    var serializedInputState = newInputState.serialize();
                    CmdReceiveInputFromClient(serializedInputState);
                }
                registerNewInputState(newInputState);
            }

            return ret;
        }

        public float GetAxis(string inputAxis) {
            return AValue.to<float>(GetInput(InputType.Axis, inputAxis));
        }
        public float GetAxisSENDTOALL(string inputAxis) {
            return AValue.to<float>(GetInputSENDTOALL(InputType.Axis, inputAxis));
        }

        public float GetAxisRaw(string inputAxis) {
            return AValue.to<float>(GetInput(InputType.AxisRaw, inputAxis));
        }
        public float GetAxisRawSENDTOALL(string inputAxis) {
            return AValue.to<float>(GetInputSENDTOALL(InputType.AxisRaw, inputAxis));
        }

        public bool GetButton(string inputAxis) {
            return AValue.to<bool>(GetInput(InputType.Button, inputAxis));
        }
        public bool GetButtonSENDTOALL(string inputAxis) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.Button, inputAxis));
        }

        public bool GetButtonUp(string inputAxis) {
            return AValue.to<bool>(GetInput(InputType.ButtonUp, inputAxis));
        }
        public bool GetButtonUpSENDTOALL(string inputAxis) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.ButtonUp, inputAxis));
        }

        public bool GetButtonDown(string inputAxis) {
            return AValue.to<bool>(GetInput(InputType.ButtonDown, inputAxis));
        }
        public bool GetButtonDownSENDTOALL(string inputAxis) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.ButtonDown, inputAxis));
        }

        public bool GetMouseButton(int buttonIndex) {
            return AValue.to<bool>(GetInput(InputType.MouseButton, buttonIndex.ToString()));
        }
        public bool GetMouseButtonSENDTOALL(int buttonIndex) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.MouseButton, buttonIndex.ToString()));
        }

        public bool GetMouseButtonUp(int buttonIndex) {
            return AValue.to<bool>(GetInput(InputType.MouseButtonUp, buttonIndex.ToString()));
        }
        public bool GetMouseButtonUpSENDTOALL(int buttonIndex) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.MouseButtonUp, buttonIndex.ToString()));
        }

        public bool GetMouseButtonDown(int buttonIndex) {
            return AValue.to<bool>(GetInput(InputType.MouseButtonDown, buttonIndex.ToString()));
        }
        public bool GetMouseButtonDownSENDTOALL(int buttonIndex) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.MouseButtonDown, buttonIndex.ToString()));
        }

        public bool GetKey(string key) {
            return AValue.to<bool>(GetInput(InputType.Key_STRING, key));
        }
        public bool GetKeySENDTOALL(string key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.Key_STRING, key));
        }

        public bool GetKey(KeyCode key) {
            return AValue.to<bool>(GetInput(InputType.Key_CODE, ((int)key).ToString()));
        }
        public bool GetKeySENDTOALL(KeyCode key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.Key_CODE, ((int)key).ToString()));
        }

        public bool GetKeyUp(string key) {
            return AValue.to<bool>(GetInput(InputType.KeyUp_STRING, key));
        }
        public bool GetKeyUpSENDTOALL(string key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.KeyUp_STRING, key));
        }

        public bool GetKeyUp(KeyCode key) {
            return AValue.to<bool>(GetInput(InputType.KeyUp_CODE, ((int)key).ToString()));
        }
        public bool GetKeyUpSENDTOALL(KeyCode key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.KeyUp_CODE, ((int)key).ToString()));
        }

        public bool GetKeyDown(string key) {
            return AValue.to<bool>(GetInput(InputType.KeyDown_STRING, key));
        }
        public bool GetKeyDownSENDTOALL(string key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.KeyDown_STRING, key));
        }

        public bool GetKeyDown(KeyCode key) {
            return AValue.to<bool>(GetInput(InputType.KeyDown_CODE, ((int)key).ToString()));
        }
        public bool GetKeyDownSENDTOALL(KeyCode key) {
            return AValue.to<bool>(GetInputSENDTOALL(InputType.KeyDown_CODE, ((int)key).ToString()));
        }
        #endregion

        #region plugins

        public AValue getPluginValue(string plugin, string key, InputReadingMethod readingMethod) {
            return pluginValueSyncer.getValue(plugin, key, readingMethod);
        }

        public void savePluginValue(string plugin, string key, AValue value) {
            pluginValueSyncer.addOrModifyValue(plugin, key, value);
        }

        protected void pluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            
            AValue value = AValue.deserialize(serializedValue);
            //savePluginValue(plugin, key, value);  // v.2.0.8+: saving is now done at PL_Messenger level

            Plugin.PL_Messenger pluginSender = null;
            foreach (Plugin.PL_Messenger pl in messengerPlugins) {
                if (pl.getUID() == plugin) {
                    pluginSender = pl;
                    break;
                }
            }

            if (pluginSender != null) {
                if (!pluginSender.hasAuthority() /* || isClient */) {  //this check ensures that the server is safe and clients cannot DOS other clients if server has authority
                                                        // v.2.0.7+: no exception anymore if client has authority

                    pluginSender.__receiveValue(key, value, timestamp);

                    if (uMMO.get.isServer && serverRelayToClients) {
                        SENDRpcPluginRecvValue(plugin, key, value, timestamp, pluginSender.QoS_ChannelID); //TODO: not send to original sender
                    }

                    if (PRINT_PLUGIN_DEBUG) {
                        print("Receiving: " + plugin + "; " + key + "; " + serializedValue + "; " + timestamp);
                    }

                } else {
                    if (uMMO.get.isServer) {
                        //TODO: report hacking
                    }
                }
            }
        }

        protected void pluginSendAdditionalFuncts(string plugin, string key, AValue value, double timestamp, bool serverRelayToClients) {
            if (PRINT_PLUGIN_DEBUG) {
                print("Sending: " + plugin + "; " + key + "; " + value.serialize() + "; " + timestamp);
            }
        }


        protected void pluginSendStatesToNewClient(NetworkConnection netC) {

            string ser = pluginValueSyncer.serialize();
#if UNITY_5_4_OR_NEWER
            TargetPluginRecvValue(netC, ser);
#else
            RpcTargetPluginRecvValue(ser);
#endif

        }
        // Unity v5.4 introduced the [TargetRpc] attribute. With it, its possible to transmit all necessary information only to new clients. Without, in order to prevent weird results and buggy looking gameplay we still use the normal [ClientRpc] attribute but it is in no way efficient because this way all information is being sent to ALL clients regardless of whether they already know this information or not.

#if UNITY_5_4_OR_NEWER
        [TargetRpc]
        protected void TargetPluginRecvValue(NetworkConnection netC, string serializedState) {
#else
        [ClientRpc]
        protected void RpcTargetPluginRecvValue(string serializedState) {
#endif

            NetState state = NetState.deserialize(serializedState);
            //print("this " + this + ": serializedState: " + serializedState);
            foreach (var pairType2Dic in state.type2key2value) {
                string plugin = pairType2Dic.Key;
                Dictionary<string, AValue> key2value = pairType2Dic.Value;
                double timestamp = double.Parse(state.timestamp);
                
                foreach (var pairKey2Val in key2value) {
                    string key = pairKey2Val.Key;
                    AValue val = pairKey2Val.Value;

                    pluginRecvValue(plugin, key, val.serialize(), timestamp, false);
                }

            }

        }

        [Command(channel = 0)]
        public void CmdCH0PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 1)]
        public void CmdCH1PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 2)]
        public void CmdCH2PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 3)]
        public void CmdCH3PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 4)]
        public void CmdCH4PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 5)]
        public void CmdCH5PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 6)]
        public void CmdCH6PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 7)]
        public void CmdCH7PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 8)]
        public void CmdCH8PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }
        [Command(channel = 9)]
        public void CmdCH9PluginRecvValue(string plugin, string key, string serializedValue, double timestamp, bool serverRelayToClients) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, serverRelayToClients);
        }

        [ClientRpc(channel = 0)]
        public void RpcCH0PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 1)]
        public void RpcCH1PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 2)]
        public void RpcCH2PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 3)]
        public void RpcCH3PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 4)]
        public void RpcCH4PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 5)]
        public void RpcCH5PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 6)]
        public void RpcCH6PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 7)]
        public void RpcCH7PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 8)]
        public void RpcCH8PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }
        [ClientRpc(channel = 9)]
        public void RpcCH9PluginRecvValue(string plugin, string key, string serializedValue, double timestamp) {
            pluginRecvValue(plugin, key, serializedValue, timestamp, false);
        }

        public void SENDCmdPluginRecvValue(string plugin, string key, AValue value, double timestamp, bool serverRelayToClients, int channelID) {
            if (channelID == 0) {
                CmdCH0PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 1) {
                CmdCH1PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 2) {
                CmdCH2PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 3) {
                CmdCH3PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 4) {
                CmdCH4PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 5) {
                CmdCH5PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 6) {
                CmdCH6PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 7) {
                CmdCH7PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 8) {
                CmdCH8PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            } else if (channelID == 9) {
                CmdCH9PluginRecvValue(plugin, key, value.serialize(), timestamp, serverRelayToClients);
            }

            pluginSendAdditionalFuncts(plugin, key, value, timestamp, serverRelayToClients);
        }

        public void SENDRpcPluginRecvValue(string plugin, string key, AValue value, double timestamp, int channelID) {
            //RpcPluginRecvValue(plugin, key, value.serialize(), timestamp);
            if (channelID == 0) {
                RpcCH0PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 1) {
                RpcCH1PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 2) {
                RpcCH2PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 3) {
                RpcCH3PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 4) {
                RpcCH4PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 5) {
                RpcCH5PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 6) {
                RpcCH6PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 7) {
                RpcCH7PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 8) {
                RpcCH8PluginRecvValue(plugin, key, value.serialize(), timestamp);
            } else if (channelID == 9) {
                RpcCH9PluginRecvValue(plugin, key, value.serialize(), timestamp);
            }

            pluginSendAdditionalFuncts(plugin, key, value, timestamp, false);
        }

#endregion

#region setup and initialization

        protected void insertPluginIfNotExists(Plugin.PL_AuthoritySerializer defaultPlugin) {
            Plugin.PL_Messenger found = null;
            //already added?
            foreach (Plugin.PL_Messenger pl_as in messengerPlugins) {
                if (pl_as.GetType() == defaultPlugin.GetType()) {
                    found = pl_as;
                    break;
                }
            }

            if (!found) {
                messengerPlugins.Add(defaultPlugin);
            }
        }

        void Awake() {
            pluginValueSyncer = new NetState(Utils.Library.NetworkTime);

            //initialize spawn case lists
            scriptLists.Add(clientLocalPlayerScripts);
            scriptLists.Add(clientRemotePlayerScripts);
            scriptLists.Add(serverPlayerScripts);
            scriptLists.Add(serverNPOScripts);
            scriptLists.Add(clientNPOScripts);

            runtimeScriptLists.Add(clientLocalPlayerRuntimeScripts);
            runtimeScriptLists.Add(clientRemotePlayerRuntimeScripts);
            runtimeScriptLists.Add(serverPlayerRuntimeScripts);
            runtimeScriptLists.Add(serverNPORuntimeScripts);
            runtimeScriptLists.Add(clientNPORuntimeScripts);

            animationComp = GetComponentInChildren<Animation>();
            if (animationComp != null) {
                if (uMMO.get.isServer) {  //prevent bug not rendering animations when not in focus of a camera
                    animationComp.cullingType = AnimationCullingType.AlwaysAnimate;
                }
                usesLegacyAnims = true;
            }

            animatorComp = GetComponentInChildren<Animator>();
            if (animatorComp != null) {
                if (uMMO.get.isServer) { //prevent bug not rendering animations when not in focus of a camera
                    animatorComp.cullingMode = AnimatorCullingMode.AlwaysAnimate;
                }
                usesMecanim = true;
            }

            //adding AuthoritySerializer plugins which are put as children of this object
            Plugin.PL_Messenger[] childrenPlugins = GetComponentsInChildren<Plugin.PL_AuthoritySerializer>();
            foreach (Plugin.PL_Messenger pl_as in childrenPlugins) {
                if (!messengerPlugins.Contains(pl_as))
                    messengerPlugins.Add(pl_as);
            }

            //create plugins automatically if wished by user?
            if (transformSyncingMethod == SyncingMethod.SyncUsing_DEFAULT_uMMO_PLUGIN) {
                insertPluginIfNotExists(uMMO.get.defaultTransformSyncingPlugin);
            }

            if (animationSyncingMethod == SyncingMethod.SyncUsing_DEFAULT_uMMO_PLUGIN) {
                if (usesLegacyAnims) {
                    insertPluginIfNotExists(uMMO.get.defaultLegacyAnimSyncingPlugin);
                }

                if (usesMecanim) {
                    insertPluginIfNotExists(uMMO.get.defaultMecanimSyncingPlugin);
                }
            }

            //initialize AuthoritySerializer plugins
            List<Plugin.PL_Messenger> newAuthSerializerPlugins = new List<Plugin.PL_Messenger>();
            foreach (Plugin.PL_Messenger pl_mp in messengerPlugins) {
                Plugin.PL_Messenger pl = Utils.Library.initPlugin(pl_mp, gameObject);
                newAuthSerializerPlugins.Add(pl);
            }

            messengerPlugins = newAuthSerializerPlugins;

        }

        // Use this for initialization
        void Start() {

            setUpNetObject();

            foreach (Plugin.PL_Messenger pl_mp in messengerPlugins) {
                pl_mp.__start();
            }
        }

        protected void setUpNetObject() {

            if (objectType == ObjectType.Player) {

                if (uMMO.get.isClient) {
                    if (isLocalPlayer) {

                        LOCAL_PLAYER_OBJECT = this;

                        //if (cameraToActivateOnLocalPlayer != null) {
                        //    switchOffMainSceneCamera();
                        //    cameraToActivateOnLocalPlayer.enabled = true;
                        //}

                        if (handelScriptsBasedOnSpawnCase)
                            handleListAndRemoveUnneccessary(clientLocalPlayerScripts);
                        if (handelScriptsBasedOnSpawnCaseAtRuntime)
                            handleListAndRemoveUnneccessary(clientLocalPlayerRuntimeScripts);

                        sendCallbackToGO("__uMMO_localPlayer_init", null);

                    } else {

                        if (handelScriptsBasedOnSpawnCase)
                            handleListAndRemoveUnneccessary(clientRemotePlayerScripts);
                        if (handelScriptsBasedOnSpawnCaseAtRuntime)
                            handleListAndRemoveUnneccessary(clientRemotePlayerRuntimeScripts);

                        sendCallbackToGO("__uMMO_remotePlayer_init", null);
                    }


                } else if (uMMO.get.isServer) {

                    uMMO.get.connections2NetObjects[connectionToClient] = this;

                    if (handelScriptsBasedOnSpawnCase)
                        handleListAndRemoveUnneccessary(serverPlayerScripts);
                    if (handelScriptsBasedOnSpawnCaseAtRuntime)
                        handleListAndRemoveUnneccessary(serverPlayerRuntimeScripts);

                    sendCallbackToGO("__uMMO_serverPlayer_init", null);

#if !UNITY_5_4_OR_NEWER
                    if (uMMO.get.showDebugHints) {
                        Debug.Log("uMMO hint: Use Unity >= version 5.4 to enable full initial game state transmission to new clients and ONLY to them. With the current version game states are being sent to EVERY client regardless of whether existing clients already have all the necessary information. This can create massive overhead.");
                    }
#endif

                    //send all game states to the new client, except for this one
                    NetObject[] netObjects = FindObjectsOfType(typeof(NetObject)) as NetObject[];
                    foreach(NetObject netObj in netObjects) {
                            netObj.pluginSendStatesToNewClient(connectionToClient);
                    }

                    //updateActivityTimestamp();

                }
            } else if (objectType == ObjectType.NonPlayerObject) {

                if (uMMO.get.isClient) {
                    if (handelScriptsBasedOnSpawnCase)
                        handleListAndRemoveUnneccessary(clientNPOScripts);
                    if (handelScriptsBasedOnSpawnCaseAtRuntime)
                        handleListAndRemoveUnneccessary(clientNPORuntimeScripts);

                    sendCallbackToGO("__uMMO_clientNPO_init", null);

                } else if (uMMO.get.isServer) {
                    if (handelScriptsBasedOnSpawnCase)
                        handleListAndRemoveUnneccessary(serverNPOScripts);
                    if (handelScriptsBasedOnSpawnCaseAtRuntime)
                        handleListAndRemoveUnneccessary(serverNPORuntimeScripts);

                    sendCallbackToGO("__uMMO_serverNPO_init", null);
                }

            } else {
                throw new Exception("uMMO NetObject '" + this.ToString() + "' object type was not set correctly.");
            }

            
        }
#endregion



    }
}